<link rel="import" href="/bower_components/polymer/polymer-element.html">
<link rel="import" href="/bower_components/polymer/src/templatizer/dom-if.html">
<link rel="import" href="/bower_components/polymerfire/firebase-app.html">
<link rel="import" href="/bower_components/polymerfire/firebase-auth.html">
<link rel="import" href="/bower_components/polymerfire/firebase-document.html">

<dom-module id="yta-firebase">
  <template>
    <firebase-app
      auth-domain="your-timetable.firebaseapp.com"
      database-url="https://your-timetable.firebaseio.com"
      api-key="AIzaSyDaMune3u4WZMti3aB66FWjX9aA_lWTLkQ"
      messaging-sender-id="806106096657">
    </firebase-app>
    <firebase-auth
      id="auth"
      online="{{online}}"
      status-known="{{statusKnown}}"
      user="{{user}}"
      provider="google">
    </firebase-auth>
    <firebase-document
      id="cloudDb"
      path="/users/[[user.uid]]"
      data="{{cloudData}}"
      disabled="[[_isCloudDisabled(statusKnown, online)]]">
    </firebase-document>
    
    <dom-if if="[[!isSW]]">
      <template>
        <app-pouchdb-conflict-resolution
          strategy="lastWriteWins">
        </app-pouchdb-conflict-resolution>
        <app-pouchdb-document
          id="pouch"
          db-name="data"
          doc-id="[[user.uid]]"
          data="{{localData}}">
        </app-pouchdb-document>
      </template>
    </dom-if>
  </template>
  
  <script>
    class FirebaseControl extends Polymer.Element {
      static get is() { return 'yta-firebase'; }
      static get config() {
        return {
          properties: {
          
            user: {
              type: Object,
              notify: true
            },
            
            data: {
              type: Object,
              notify: true
            },
            
            cloudData: {
              type: Object,
              observer: '_cloudChanged'
            },
            
            localData: {
              type: Object,
              observer: '_pushToPouch'
            },
            
            satusKnown: {
              type: Boolean
            },
            
            online: {
              type: Boolean
            },
            
            isSW: {
              type: Boolean,
              value: () => {
                return 'serviceWorker' in navigator;
              }
            }
            
          },
          
          observers: [
            'newData(data.*)'
          ],
        };
      }
      
      constructor() {
        super();
      }
      
      ready() {
        super.ready();
        
        // Add event listeners
        const this1 = this;
        window.addEventListener('FIREBASE-sign-in-required', e => {
          const isAnnonymous = e.detail.provider === 'google' ? false
                                                              : true;
          isAnnonymous ? this1.signInAnonymously()
                       : this1.signIn();
        });
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this._auth = this.$.auth;
        
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            if (this.isSW) {
              this._loadPouchDB();
            } else {
              importHref('/bower_components/app-pouchdb/app-pouchdb-document.html');
              importHref('/bower_components/app-pouchdb/app-pouchdb-conflict-resolution.html');
            }
            this.setData();
          });
        });
      }
      
      signIn() {
        return new Promise((resolve, reject) => {
          this._auth.signInWithPopup().then(resp => {
            this._fire('FIREBASE-signed-in', { annonymous: false, user: this.user }, true, window);
            resolve(resp);
          }, err => {
            console.error('Sign in failed', 'annonymous == false', err);
            this._fire('FIREBASE-sign-in-failed', null, true, window);
            reject(err);
          });
        });
      }
      
      signInAnonymously() {
        return new Promise((resolve, reject) => {
          this._auth.signInAnonymously().then(resp => {
            this._fire('FIREBASE-signed-in', { annonymous: true, user: this.user }, true, window);
            resolve(resp);
          }, err => {
            console.error('Sign in failed', 'annonymous == true', err);
            this._fire('FIREBASE-sign-in-failed', null, true, window);
            reject(err);
          });
        });
      }
      
      signOut() {                                                                           // Never resolves
        return new Promise((resolve, reject) => {
          this._auth.signOut().then(() => {
            this._fire('FIREBASE-signed-out');
            return this.isSW ? sendMessage({ cmd: 'deletePouch' })
                                : this.shadowRoot.querySelector('#pouch').destroy();
          }, err => {
            console.error('Sign out failed', err);
            reject(err);
          }).catch(err => {
            console.error('Error deleting Pouch', err);
            reject(err);
          });
        });
      }
      
      newData(changeRecord) {
        requestIdleCallback(deadline => {
          const upload = this.data;
          upload.lastEdit = Date.now();
          this.cloudData = upload;
          this.localData = upload;
        });
      }
      
      setData() {
        this._waitForData().then(() => {
          const cloudData = this.cloudData;
          const localData = this.localData;
          if (!(localData && Object.keys(localData).length !== 0) && (cloudData && Object.keys(cloudData).length !== 0)) {
            this.data = cloudData;
          } else if (!(cloudData && Object.keys(cloudData).length !== 0) && (localData && Object.keys(localData).length !== 0)) {
            this.data = localData;
          } else if (!(cloudData && Object.keys(cloudData).length !== 0) && !(localData && Object.keys(localData).length !== 0)) {
            this.data = {};
            this._fire('FIREBASE-setup-requested');
            this._dataChangeAllowed = true;
            return;
          } else {
            const lastCloud = cloudData.lastEdit;
            const lastLocal = localData.lastEdit;
            if (lastLocal >= lastCloud) {
              this.data = localData;
            } else {
              this.data = cloudData;
            }
          }
          if (!this.data.config || !this.data.settings || !this.data.timetable) {
            this._fire('FIREBASE-setup-requested');
          }
          this._dataChangeAllowed = true;
        });
      }
      
      _loadPouchDB() {
        return new Promise((resolve, reject) => {
          // Resolve if this function has been already called
          if (this._pouchReady) resolve();
          
          // Resolve if SW reports it has got Pouch working
          sendMessage({ cmd: 'checkPouch' }).then(() => {
            this._pouchReady = true;
            resolve();
          }).catch(() => {
            // Else, set up Pouch on SW
            this._waitForUser().then(user => {
              sendMessage({ cmd: 'setupPouch', uid: user.uid }).then(() => {
                this._pouchReady = true;
                resolve();
              }).catch(err => {
                reject(err);
              });
            });
          });
        });
      }
      
      _waitForUser() {
        const auth = new Promise(r => {
          const authObj = this.$.auth;
          
          if (authObj.statusKnown) r();
          
          authObj.addEventListener('status-known-changed', () => r(), { once: true });
        });
        
        const user = new Promise(r => {
          auth.then(() => {
            this.user ? r()
                      : this._fire('FIREBASE-no-user');
            
            const auth = this.$.auth.auth;
            auth.onAuthStateChanged(user => {
              if (user) r(user);
            });
          });
        });
        
        return Promise.all([auth, user]).then(() => this.user);
      }
      
      _waitForData() {
        const cloud = new Promise(r => {
          if (this.cloudData && Object.keys(this.cloudData).length !== 0) {
            r(this.cloudData);
          } else {
            this._waitForUser().then(user => {
              firebase.database().ref('users/' + user.uid).once('value', snapshot => {
                r(snapshot.val());
              });
            });
          }
        });
        
        const local = new Promise(r => {
          if (this.localData && Object.keys(this.localData).length !== 0) {
            r(this.localData);
          } else {
            if (this.isSW) {
              this._loadPouchDB().then(() => {
                sendMessage({ cmd: 'readData' }).then(val => r(val));
              });
            } else {
              this.shadowRoot.querySelector('app-pouchdb-document').addEventListener('data-changed', val => {
                r(val);
              }, { once: true });
            }
          }
        });
        
        return Promise.all([cloud, local]);
      }
      
      _pushToPouch(data) {
        if (!this._dataChangeAllowed) return;
        if (this.isSW) {
          if (!this._pouchReady) {
            this._loadPouchDB().then(() => sendMessage({ cmd: 'pushToPouch', data }));
          }
          sendMessage({ cmd: 'pushToPouch', data });
        }
      }
      
      _cloudChanged(data, oldData) {
        if (!this.$.cloudDb.ref || !this._dataChangeAllowed) return;
        if (data.lastEdit > this.data.lastEdit) {
          //this.data = data;                                                                     // No live changes - brings infinite loops
        } else {
          this.$.cloudDb.ref.set(data);
        }
      }
      
      _isCloudDisabled(online = this.online, statusKnown = this.statusKnown) {
        return !online || !statusKnown;
      }
      
      _fire(name, detail = null, bubbles = true, target) {
        target = target || this;
        const evt = new CustomEvent(name, { detail, bubbles });
        target.dispatchEvent(evt);
      }
    }
    
    customElements.define(FirebaseControl.is, FirebaseControl);
    
    // From https://googlechrome.github.io/samples/service-worker/post-message/
    function sendMessage(message) {
      return new Promise(function(resolve, reject) {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = event => {
          if (event.data.error) {
            reject(event.data.error);
          } else {
            resolve(event.data);
          }
        };
        
        navigator.serviceWorker.controller.postMessage(message,
          [messageChannel.port2]);
      });
    }
  </script>
</dom-module>