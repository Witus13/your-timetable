<link rel="import" href="/bower_components/polymer/polymer-element.html">
<link rel="import" href="/bower_components/polymer/src/templatizer/dom-if.html">
<link rel="import" href="/bower_components/polymerfire/firebase-app.html">
<link rel="import" href="/bower_components/polymerfire/firebase-auth.html">
<link rel="import" href="/bower_components/polymerfire/firebase-document.html">

<dom-module id="yta-firebase">
  <template>
    <firebase-app
      auth-domain="your-timetable.firebaseapp.com"
      database-url="https://your-timetable.firebaseio.com"
      api-key="AIzaSyDaMune3u4WZMti3aB66FWjX9aA_lWTLkQ"
      messaging-sender-id="806106096657">
    </firebase-app>
    <firebase-auth
      id="auth"
      online="{{online}}"
      status-known="{{statusKnown}}"
      user="{{user}}"
      provider="google">
    </firebase-auth>
    <firebase-document
      id="cloudDb"
      path="/users/[[user.uid]]"
      data="{{cloudData}}"
      disabled="[[_isCloudDisabled(statusKnown, online)]]">
    </firebase-document>
    
    <dom-if if="[[!isSW]]">
      <template>
        <app-pouchdb-conflict-resolution
          strategy="lastWriteWins">
        </app-pouchdb-conflict-resolution>
        <app-pouchdb-document
          id="pouch"
          db-name="data"
          doc-id="[[user.uid]]"
          data="{{localData}}">
        </app-pouchdb-document>
      </template>
    </dom-if>
  </template>
  
  <script>
    class FirebaseControl extends Polymer.Element {
      static get is() { return 'yta-firebase'; }
      static get config() {
        return {
          properties: {
          
            user: {
              type: Object,
              notify: true
            },
            
            data: {
              type: Object,
              notify: true
            },
            
            cloudData: {
              type: Object,
              observer: '_cloudChanged'
            },
            
            localData: {
              type: Object,
              observer: '_pushToPouch'
            },
            
            satusKnown: {
              type: Boolean
            },
            
            online: {
              type: Boolean
            },
            
            isSW: {
              type: Boolean,
              value: () => {
                return 'serviceWorker' in navigator;
              }
            }
            
          },
          
          observers: [
            'newData(data.*)'
          ],
        };
      }
      
      constructor() {
        super();
      }
      
      ready() {
        super.ready();
        
        // Add event listeners
        const this1 = this;
        window.addEventListener('FIREBASE-sign-in-required', e => {
          const isAnnonymous = e.detail.provider === 'google' ? false
                                                              : true;
          isAnnonymous ? this1.signInAnonymously()
                       : this1.signIn();
        });
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this._auth = this.$.auth;
        
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            if (this.isSW) {
              this._loadPouchDB();
            } else {
              importHref('/bower_components/app-pouchdb/app-pouchdb-document.html');
              importHref('/bower_components/app-pouchdb/app-pouchdb-conflict-resolution.html');
            }
            this.setData();
          });
        });
      }
      
      signIn() {
        return new Promise((resolve, reject) => {
          this._auth.signInWithPopup().then(resp => {
            this._fire('FIREBASE-signed-in', { annonymous: false, user: this.user });
            resolve(resp);
          }, err => {
            console.error('Sign in failed', 'annonymous == false', err);
            this._fire('FIREBASE-sign-in-failed');
            reject(err);
          });
        });
      }
      
      signInAnonymously() {
        return new Promise((resolve, reject) => {
          this._auth.signInAnonymously().then(resp => {
            this._fire('FIREBASE-signed-in', { annonymous: true, user: this.user });
            resolve(resp);
          }, err => {
            console.error('Sign in failed', 'annonymous == true', err);
            this._fire('FIREBASE-sign-in-failed');
            reject(err);
          });
        });
      }
      
      signOut() {
        return new Promise((resolve, reject) => {
          this._auth.signOut().then(() => {
            this._fire('FIREBASE-signed-out');
            return this.isSW ? sendMessage({ cmd: 'deletePouch' })
                                : this.shadowRoot.querySelector('#pouch').destroy();
          }, err => {
            console.error('Sign out failed', err);
            reject(err);
          }).catch(err => {
            console.error('Error deleting Pouch', err);
            reject(err);
          });
        });
      }
      
      newData(changeRecord) {
        requestIdleCallback(deadline => {
          this.cloudData = this.data;
          this.localData = this.data;
        });
      }
      
      setData() {
        this._waitForData().then(() => {
          const cloudData = this.cloudData;
          const localData = this.localData;
          if (!localData && cloudData) {
            this.data = cloudData;
          } else if (!cloudData && localData) {
            this.data = localData;
          } else if (!cloudData && !localData) {
            this.data = {};
          } else {
            const lastCloud = cloudData.lastEdit;
            const lastLocal = localData.lastEdit;
            if (lastLocal >= lastCloud) {
              this.data = localData;
            } else {
              this.data = cloudData;
            }
          }
        });
      }
      
      _loadPouchDB() {
        // Return if this function has been already called
        if (this._pouchReady) return;
        
        // Return if SW reports it has got Pouch working
        sendMessage({ cmd: 'checkPouch' }).then(() => {
          this._pouchReady = true;
        }).catch(() => {
          // Else, set up Pouch on SW
          this._waitForUser().then(user => {
            sendMessage({ cmd: 'setupPouch', uid: user.uid }).then(() => {
              this._pouchReady = true;
              return;
            }).catch(err => {
              console.error('Error setting up PouchDB on service worker', err);
            });
          });
        });
      }
      
      _waitForUser() {
        const auth = new Promise(r => {
          const authObj = this.$.auth;
          
          if (authObj.statusKnown) r();
          
          authObj.addEventListener('status-known-changed', () => r(), { once:true });
        });
        
        const user = new Promise(r => {
          auth.then(() => {
            this.user ? r()
                      : this._noUser();
            
            const auth = this.$.auth.auth;
            auth.onAuthStateChanged(user => {
              if (user) r(user);
            });
          });
        });
        
        return Promise.all([auth, user]).then(() => this.user);
      }
      
      _waitForData() {
        const cloud = new Promise(r => {
          if (Object.keys(this.cloudData).length !== 0) {
            r(this.cloudData);
          } else {
            this._waitForUser().then(user => {
              firebase.database().ref('users/' + user.uid).once('value', snapshot => {
                r(snapshot.val());
              });
            })
          }
        });
        
        const local = new Promise(r => {
          if (this.localData) {
            r(this.localData);
          } else {
            if (this.isSW) {
              this._loadPouchDB();
              sendMessage({ cmd: 'readData' }).then(val => r(val)).catch(err => {
                if (err === 'Pouch not Pouch is unavailable') this._loadPouchDB().then(() => {
                  sendMessage({ cmd: 'readData' }).then(val => r(val));
                });
              });
            } else {
              this.shadowRoot.querySelector('app-pouchdb-document').addEventListener('data-changed', val => {
                r(val);
              });
            }
          }
        });
        
        return Promise.all([cloud, local]);
      }
      
      _noUser() {
        this._fire('FIREBASE-no-user');
        this._fire('switch-page', { action: 'openOnboarding' });
      }
      
      _pushToPouch(data) {
        if (this.isSW) {
          if (!this._pouchReady) {
            this._loadPouchDB();
            this._pushToPouch(data);
            return;
          }
          sendMessage({ cmd: 'pushToPouch', data });
        }
      }
      
      _cloudChanged(data, oldData) {
        if (!this.$.cloudDb.ref) return;
        if (data != this.data) {
          this.data = data;
        } else {
          this.$.cloudDb.ref.set(data);
        }
      }
      
      _isCloudDisabled(online = this.online, statusKnown = this.statusKnown) {
        return online && statusKnown;
      }
      
      _fire(name, details = null, bubbles = true) {
        const evt = new CustomEvent(name, { detail: details });
        this.dispatchEvent(evt, { bubbles });
      }
    }
    
    customElements.define(FirebaseControl.is, FirebaseControl);
    
    // From https://googlechrome.github.io/samples/service-worker/post-message/
    function sendMessage(message) {
      return new Promise(function(resolve, reject) {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = event => {
          if (event.data.error) {
            reject(event.data.error);
          } else {
            resolve(event.data);
          }
        };
        
        navigator.serviceWorker.controller.postMessage(message,
          [messageChannel.port2]);
      });
    }
  </script>
</dom-module>