<link rel="import" href="/bower_components/polymer/polymer-element.html">
<link rel="import" href="/bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="/bower_components/polymerfire/firebase-app.html">
<link rel="import" href="/bower_components/polymerfire/firebase-auth.html">
<link rel="import" href="/bower_components/polymerfire/firebase-document.html">

<dom-module id="yta-firebase">
  <template>
    <firebase-app
      auth-domain="your-timetable.firebaseapp.com"
      database-url="https://your-timetable.firebaseio.com"
      api-key="AIzaSyDaMune3u4WZMti3aB66FWjX9aA_lWTLkQ"
      messaging-sender-id="806106096657">
    </firebase-app>
    <firebase-auth
      id="auth"
      online="{{online}}"
      status-known="{{statusKnown}}"
      user="{{user}}"
      provider="google">
    </firebase-auth>
    <firebase-document
      id="cloudDb"
      path="/users/[[user.uid]]"
      on-data-changed="_cloudChanged"
      disabled="[[_isCloudDisabled(statusKnown, online)]]">
    </firebase-document>
    
    <dom-if if="[[!_isSW()]]">
      <template>
        <app-pouchdb-conflict-resolution
          strategy="lastWriteWins">
        </app-pouchdb-conflict-resolution>
        <app-pouchdb-document
          id="pouch"
          db-name="data"
          doc-id="[[user.uid]]"
          data="{{localData}}">
        </app-pouchdb-document>
      </template>
    </dom-if>
  </template>
  
  <script>
    class FirebaseControl extends Polymer.Element {
      static get is() { return 'yta-firebase'; }
      static get properties() {
        return {
        
          user: {
            type: Object,
            notify: true
          },
          
          data: {
            type: Object,
            notify: true
          },
          
          cloudData: Object,
          
          localData: Object,
          
          satusKnown: {
            type: Boolean
          },
          
          online: {
            type: Boolean
          }
          
        };
      }
      
      static get observers() {
        return [
          'newData(data.*)'
        ];
      }
      
      constructor() {
        super();
      }
      
      ready() {
        super.ready();
        
        // Add event listeners
        const this1 = this;
        window.addEventListener('firebasesigninrequired', e => {
          const isAnnonymous = e.detail.provider === 'google' ? false
                                                              : true;
          isAnnonymous ? this1.signInAnonymously()
                       : this1.signIn();
        });
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this._auth = this.$.auth;
        
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            if (this._isSW()) {
              this._loadPouchDB();
            } else {
              importHref('/bower_components/app-pouchdb/app-pouchdb-document.html');
              importHref('/bower_components/app-pouchdb/app-pouchdb-conflict-resolution.html');
              this._pouchReady = true;
            }
            this.setData();
          });
        });
      }
      
      signIn() {
        return new Promise((resolve, reject) => {
          this._auth.signInWithPopup().then(resp => {
            this._fire('firebasesignedin', { annonymous: false, user: this.user }, true, window);
            resolve(resp);
          }, err => {
            console.error('Sign in failed', 'annonymous == false', err);
            this._fire('firebasesigninfailed', null, true, window);
            reject(err);
          });
        });
      }
      
      signInAnonymously() {
        return new Promise((resolve, reject) => {
          this._auth.signInAnonymously().then(resp => {
            this._fire('firebasesignedin', { annonymous: true, user: this.user }, true, window);
            resolve(resp);
          }, err => {
            console.error('Sign in failed', 'annonymous == true', err);
            this._fire('firebasesigninfailed', null, true, window);
            reject(err);
          });
        });
      }
      
      signOut() {
        return new Promise((resolve, reject) => {
          this._auth.signOut().then(() => {
            this._fire('firebasesignedout');
            return this._isSW() ? sendMessage({ cmd: 'deletePouch' })
                                : this.shadowRoot.querySelector('#pouch').destroy();
          }, err => {
            console.error('Sign out failed', err);
            reject(err);
          }).catch(err => {
            console.error('Error deleting Pouch', err);
            reject(err);
          });
        });
      }
      
      newData(changeRecord) {
        //requestIdleCallback(deadline => {
          const upload = this.data;
          upload.lastEdit = Date.now();
          this._pushToCloud(upload);
          this.localData = upload;
          this._pushToPouch(upload);
          if (!this._dataReady && this.data.config && this.data.settings && this.data.timetable) {
            this._fire('firebasedataready');
            this._dataReady = true;
          }
        //});
      }
      
      setData() {
        if (!this.online) {
          new Promise(r => {
            if (this.localData && Object.keys(this.localData).length !== 0) {
              r(this.localData);
            } else {
              if (this._isSW()) {
                this._loadPouchDB().then(() => {
                  sendMessage({ cmd: 'readData' }).then(val => r(val));
                });
              } else {
                this.shadowRoot.querySelector('app-pouchdb-document').addEventListener('data-changed', val => {
                  r(val);
                }, { once: true });
              }
            }
          }).then(res => {
            delete res._id;
            delete res._rev;
            if (res && Object.keys(res).length !== 0) {
              this.data = res;
            }
          });
        }
        this._waitForData().then(res => {
          const cloudData = res[0];
          const localData = res[1];
          delete localData._id;
          delete localData._rev;
          this._dataChangeAllowed = true;
          if (!(localData && Object.keys(localData).length !== 0) && (cloudData && Object.keys(cloudData).length !== 0)) {
            this.data = cloudData;
          } else if (!(cloudData && Object.keys(cloudData).length !== 0) && (localData && Object.keys(localData).length !== 0)) {
            this.data = localData;
          } else if (!(cloudData && Object.keys(cloudData).length !== 0) && !(localData && Object.keys(localData).length !== 0)) {
            this.data = {};
            this._fire('firebasesetuprequested');
            return;
          } else {
            const lastCloud = cloudData.lastEdit;
            const lastLocal = localData.lastEdit;
            if (lastCloud >= lastLocal) {
              this.data = cloudData;
            } else {
              this.data = localData;
            }
          }
          if (!this.data.config || !this.data.settings || !this.data.timetable) {
            this._fire('firebasesetuprequested');
          } else {
            this._fire('firebasedataready');
            this._dataReady = true;
          }
        });
      }
      
      _loadPouchDB() {
        return new Promise((resolve, reject) => {
          // Resolve if this function has been already called
          if (this._pouchReady) resolve();
          
          // Resolve if SW reports it has got Pouch working
          sendMessage({ cmd: 'checkPouch' }).then(() => {
            this._pouchReady = true;
            resolve();
          }).catch(() => {
            // Else, set up Pouch on SW
            this._waitForUser().then(user => {
              sendMessage({ cmd: 'setupPouch', uid: user.uid }).then(() => {
                this._pouchReady = true;
                resolve();
              }).catch(err => {
                reject(err);
              });
            });
          });
        });
      }
      
      _waitForUser() {
        const auth = new Promise(r => {
          const authObj = this.$.auth;
          
          if (authObj.statusKnown) r();
          
          authObj.addEventListener('status-known-changed', () => r(), { once: true });
        });
        
        const user = new Promise(r => {
          auth.then(() => {
            this.user ? r()
                      : this._fire('firebasenouser');
            
            const auth = this.$.auth.auth;
            auth.onAuthStateChanged(user => {
              if (user) r(user);
            });
          });
        });
        
        return Promise.all([auth, user]).then(() => this.user);
      }
      
      _waitForData() {
        const cloud = new Promise(r => {
          if (this.cloudData && Object.keys(this.cloudData).length !== 0) {
            r(this.cloudData);
          } else {
            this._waitForUser().then(user => {
              firebase.database().ref('users/' + user.uid).once('value', snapshot => {
                r(snapshot.val());
              });
            });
          }
        });
        
        const local = new Promise(r => {
          if (this.localData && Object.keys(this.localData).length !== 0) {
            r(this.localData);
          } else {
            if (this._isSW()) {
              this._loadPouchDB().then(() => {
                sendMessage({ cmd: 'readData' }).then(val => r(val));
              });
            } else {
              this.shadowRoot.querySelector('app-pouchdb-document').addEventListener('data-changed', val => {
                r(val);
              }, { once: true });
            }
          }
        });
        
        return Promise.all([cloud, local]);
      }
      
      _pushToPouch(data) {
        if (!this._dataChangeAllowed) return;
        if (this._isSW()) {
          if (!this._pouchReady) {
            this._loadPouchDB().then(() => sendMessage({ cmd: 'pushToPouch', data }));
          }
          sendMessage({ cmd: 'pushToPouch', data });
        }
      }
      
      _pushToCloud(data) {
         if (!this.$.cloudDb.ref || !this._dataChangeAllowed) return;
         this.$.cloudDb.ref.set(data);
      }
      
      _cloudChanged(e) {
        if (!this.$.cloudDb.ref || !this._dataChangeAllowed) return;
        const data = this.$.cloudDb.data;
        if (data.lastEdit > this.data.lastEdit) {
          this.data = data;
        }
      }
      
      _isCloudDisabled(online = this.online, statusKnown = this.statusKnown) {
        return !online || !statusKnown;
      }
      
      _isSW() { return 'serviceWorker' in navigator; }
      
      _fire(name, detail = null, bubbles = true, target) {
        target = target || this;
        const evt = new CustomEvent(name, { detail, bubbles });
        target.dispatchEvent(evt);
      }
    }
    
    customElements.define(FirebaseControl.is, FirebaseControl);
    
    // From https://googlechrome.github.io/samples/service-worker/post-message/
    function sendMessage(message) {
      return new Promise(function(resolve, reject) {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = event => {
          if (event.data.error) {
            reject(event.data.error);
          } else {
            resolve(event.data);
          }
        };
        
        navigator.serviceWorker.ready.then(reg => reg.active.postMessage(message,[messageChannel.port2]));
      });
    }
  </script>
</dom-module>